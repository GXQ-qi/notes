---
tags:
  - 自动机
  - "#右线性文法与正则语言"
aliases:
---
## 有限自动机
### 有限状态机的形式定义
> [! ] 定义
> **确定的**有限状态自动机(DFA)是一个五元组M = (Q, T, δ, q0, F)
>- Q: 有限的状态集合
>- T: 有限的**输入**字母表
>- **δ**: 转换函数, 是从Q×T到Q的映射 -> **δ' **是描述在某个状态下接受多个输入映射到下一个函数的函数
>- q0: 起始状态, q0∈Q
>- F: 终止状态集合, F是Q的子集

### 表示方法
#### 状态转移图
- 初始状态箭头指向
- 终止状态两个圈圈
#### 状态转换表
- 初始状态箭头指向, 终止状态加星标
- 行头表示状态
- 列头表示输入
#### 格局
用来描述有限自动机的工作过程
对于它在某一时刻的工作状态可以用两个信息表示: 
- 在该时刻所处的状态q
- 该时刻等待输入的字符串w -> 最左边的最先输入
用|——来连接两个格局
### 设计有限自动机
- 找出状态
- 找出转移
- 画状态转移图
---
### 不确定的有限自动机NFA
相对于确定的自动机, 不确定的自动机在每一个状态下接收到入后的下一个状态不确定
- 可以用树来判断输入串是否接受, 也可以试试贪婪算法: 尽量向结束状态靠近.
- 不确定性也可以看作若干个"过程"能同时运行一类**并行计算**
- 
**不确定的**有限状态自动机NFA是一个五元组 M = {Q, T, δ, q0, F}, 与DFA不同的**仅是转换函数δ不同**
δ是从Q×T到2^Q的映射

### DFA与NFA的等效
DFA是NFA的特例
#### 定理: 设L(MN)是由NFA-MN接受的语言, 则存在一台确定的有限状态自动机MD, 接受L(MD), 满足L(MN) = L(MD)

-> 也就是每一台NFA都有与之对应的DFA, 他们接受相同的语言
#### 构造方式
##### 子集构造法
DFA的状态为NFA中可能出现的状态集合的集合.
将NFA的状态集合看作DFA的一个状态: ->例: NFA某一个状态的下一个状态可能是{q0, q1}, 那么DFA中就有状态［q0, q1].
如此, DFA的状态为NFA状态集合子集的集合, 因此称为子集构造法.
详细方法看例题: ![[NFA等效DFA例题.png]]
> [! 子集构造法简化版]
> 子集构造法需要列出全部的2^Q作为DFA的状态集合, 但是当NFA有比较多的状态时, DFA应有的状态就会很多
> 解决办法是换一种找DFA状态的方法. 因为并不是所有的2^Q的状态都会达到, 所以可以只找通过q0能达到的状态作为DFA的状态. -> 在NFA中从q0开始, 每次都从现有的状态开始, 将通过一次输入(所有的输入可能尝试一遍)能到达的状态添加到状态集中, 重复以上步骤.
### 带ε转换的NFA
#### 定义:
当输入空串(无输入)时,也能引起状态的转移
是一个五元组 A = (Q, T, δ, q0, F)
但是**转移函数是 Q×T∪{ε} → 2^Q**

#### ε-闭包
- 定义为从某个状态q经过**所有ε路径**可以到达的状态的集合, *包含它自身*, 记为ε-CLOSURE(q)
- 状态子集I的闭包为I所有元素的ε-闭包的集合
- Ia的概念: 状态子集I 通过输入a得到的状态集合的ε-闭包
- δ'(q, ε) : 从q出发经过a路径或ε路径能到达的状态集合
- δ'(q, a): 从q出发经过{ε, a}\*字符串能到达的状态集合
#### 语言
定义一个ε - NFA M = (Q, T, δ, q0, F)
定义M的语言: L(M) = {ω | δ'(q0, ω) ∩ F != 空集}
#### 构造等价的NFA
设ε- NFA M = (Q, T, δ, q0, F), 尝试构造等价的NFA M1
> [! ] 由ε-NFA构造NFA
> M1 = (Q, T, δ1, q0, F1), 其中:
> - Q, T, q0都未改变
> - δ1(q, a) = δ'(q, a) -> 易错: 表示从q经过aε构成的字符串能到达的状态!
> - F1 = F∩ε-CLOSURE(q0) = 空集 ? F∪{q0} : F

## 正则集与正则式
- 正则集: 特殊字符串的集合
- 正则式(regular expression): 用类似代数表达式的方法表示语言
- 运算符: +(联合)   ·(连接)   \*(星闭包)

> [! ] 递归定义
> 1. ε和空集都是正则表达式, 分别表示的正则集是{ε}和空集
> 2. 任意a∈T是正则式, 他表示的正则集是{a}
> 3. 如果A和B都是正则式, 分别表示的正则集是L(A)和L(B), 则(A + B), (A · B), (A\*)也都是正则式, 分别表示的正则集是L(A)∪L(B), L(A)L(B), L(A)*
### 右线性文法与正则集
正则集是由右线性文法产生的语言, 二者是等同的
右线性文法/有限自动机/正则表达式都定义了一种语言 -- 正则语言
> [! ] 定义
> 一个语言是正则集, 当且仅当该语言为正则语言
### 正则表达式与有限自动机
 [[有限自动机和右线性文法关系图]]
### 有限性文法的性质

- 最小化DFA
- 正则语言的特点
##### 定义
**等价状态**: 若两个状态经过相同字符串能达到终止状态, 则称两个状态等价
**不可达状态**: 从初始状态出发无法到达的状态称为不可达状态
**最小化**: 若DFA中不存在不可达状态和相互等价的状态, 称该DFA M为最小化的, 或称为化简的

#### 最小化算法
对于一个M的化简, 就是将M的状态集Q构成一个划分.
##### 填表法
> [! 填表法定义]
> - 基础  终结状态p与非终结状态q标记为可区分
> - 归纳  若有δ(r, a) = p, δ(s, a) = q, 则标记r与s也是可区分的
##### 步骤
1. 删除不可达状态
2. 用填表法划分Q
3. 经过2划分后的每个划分块之间的状态都相互等价, 不同划分块之间的状态是可区分的. 包含q的划分快称为{q} -- 类似于等价类
	1. 构造与A等价的优化后的B = {Q1, T1, δ1, \[q0], F1} -> Q1 = {\[q] | q∈Q}, F1 = {\[q] | q∈F}, δ1(\[q], a) = \[δ(q, a)]
#### 泵浦引理 -- pumping
> [! 泵浦引理]
> - 语言描述: 当给定一个正则集和其中一个足够长的字符串, 重复该字符串中的一个字串若干次, 得到的新字符串也属于该正则集.
> - 一般用于反证一条语言不属于正则集

### 右线性语言的封闭性
右线性语言对于并∪、连接•、星闭包*、补﹣、交∩、置换 运算都是封闭的
#### 判定问题
- 判定是否为空
- 判定成员
- 判定等价
## 双向和有输出的有限自动机
读写头可以左移与可以右移, 也可以不移动
2DFA(确定的双向有限自动机)只有左移与右移, 不能不移动
> [! 2DFA定义]
> 2DFA的自动机M = 
>
> - δ = Q × T → Q × {L, R}

### 有输出的有限自动机
在状态转换时, 可以引起字符输出
- 米兰机: 输出字符与输入字符及自身状态有关
- 摩尔机: 输出字符仅与自身状态有关

> [! 米兰机定义]
> M = (Q, T, R, δ, g, q0)
> - R是输出字符的集合
> - g是Q × T → R

> [! 摩尔机定义]
> 类似于米兰机, 但g 是Q → R

[[米兰机与摩尔机转换图]]
#### 米兰机和摩尔机的变换
##### 摩尔机构造等价的米兰机
若M中有 δ(q, a), g(p)
则对应的M' 中 g'(q, a) = b = g(δ(q, a))
##### 米兰机构造等价的摩尔机

略
## 正则表达式和有限自动机的应用
